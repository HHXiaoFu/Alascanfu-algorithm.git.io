# 题目
>给定一个整数 n ，返回 n! 结果中尾随零的数量。

>提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1



示例1：

```txt
输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
```
示例2：

```txt
输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
```
示例3：

```txt
输入：n = 0
输出：0
```


## 提示
`0 <= n <= 10^4`
## 📝思路📝

**本题考查知识点**
> [大佬的题解](https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/)

- 小付理解的思路：`末尾有多少个零取决于的是有多少个偶数乘以5`可以`构成一个10 `进行`相乘这样末尾就会多增加一个0` 这样就可以知道每个数可以有几个2和5构成，每对2和5就能构成一个尾部零，我们`只需要能凑够多少对数就知道尾部会有多少个0了`，知道这个了我们`就需要知道2和5在n!中出现的次数少的那个就是二者能够出现最多的对数`，可以很清楚的知道，`5的个数肯定比2的个数少`，**所以我们只需要求取每次需要进行乘的数能分出多少个5的个数就知道就多少个尾部0了。**

- `不出意外这题是可以过得`，不过这只是考虑了给定的 n 为 $10^4$ 以内，`如果 n 给定的数值是足够大的话`，那么`很大情况这道题会超时`，因为按照上述的方法做出来其时间复杂度为 $O(nlogn)$ ,如果给定的 n 为 $10^8$ 这题`绝对会TLE` ,所以官方放我们设计一个时间复杂度为 $O(logn)$ 的算法来处理，我们接着来看，如何对上述的代码进行优化，**我们本质是为了求每个数中 5 的个数**，那么`如果数等于 25 时`，`里面就是有 2 个 5 `，那么`以此类推`就`能知道125 = 5*5*5 `那么`每当125个数字时就是要+3个5`所以总共 5 的个数是 $n/5 + n/25 + n/125 + ... + n/5^n$ 剩下的就交给程序计算即可。 
## 代码实现
**暴力数学**
```java
class Solution {
    public int trailingZeroes(int n) {
        int cnt = 0 ;
        for (int i = 1; i<= n;i++){
            int curNum = i;
            while(curNum > 0){
                if (curNum % 5 == 0){
                    cnt++;
                    curNum/=5;
                }else {
                    break;
                }
            }
        }
        return cnt;
    }
}
```

- **时间复杂度:** O($nlogn$)  
- **空间复杂度:** O($1$)

**数学优化**
```java
class Solution {
    public int trailingZeroes(int n) {
        int cnt = 0 ;
        while (n > 0){
            cnt = cnt +  n / 5; //  n/5 + n/25 + ... +> n/5^n
            n = n / 5;//  n/5 --> n/25 --> ... --> n/5^n
        }
        return cnt;
    }
}
```

- **时间复杂度:** O($logn$)  
- **空间复杂度:** O($1$)


## 运行结果
**暴力数学**

![image.png](https://pic.leetcode-cn.com/1648218570-zCCzxl-image.png)




**数学优化**
![image.png](https://pic.leetcode-cn.com/1648218500-pafILF-image.png)
